package modrinth

import (
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"net/http"

	"lucy/logger"

	"lucy/datatypes"
	"lucy/local"
	"lucy/lucytypes"
)

// TODO: Refactor to separate all API functions to accept an url. While the urls
// are generated by other functions. This will make the code more modular and
// easier to test.

var ErrorVersionNotFound = errors.New("modrinth version not found")

func listVersions(slug lucytypes.PackageName) (versions []*datatypes.ModrinthVersion) {
	res, _ := http.Get(versionsUrl(slug))
	data, _ := io.ReadAll(res.Body)
	json.Unmarshal(data, &versions)
	return
}

// getVersion is named as so because a Package in lucy is equivalent to a version
// in Modrinth.
func getVersion(id lucytypes.PackageId) (
	v *datatypes.ModrinthVersion,
	err error,
) {
	versions := listVersions(id.Name)
	if id.Version == lucytypes.LatestVersion {
		return latestVersion(id.Name), nil
	}
	for _, version := range versions {
		if version.VersionNumber == id.Version &&
			versionSupportsLoader(version, id.Platform) {
			return version, nil
		}
	}
	return nil, fmt.Errorf("%w: %s", ErrorVersionNotFound, id.String())
}

func getVersionById(id string) (v *datatypes.ModrinthVersion) {
	res, _ := http.Get(versionUrl(id))
	data, _ := io.ReadAll(res.Body)
	v = &datatypes.ModrinthVersion{}
	json.Unmarshal(data, v)
	return
}

func versionSupportsLoader(
	version *datatypes.ModrinthVersion,
	loader lucytypes.Platform,
) bool {
	for _, l := range version.Loaders {
		if lucytypes.Platform(l).Eq(loader) {
			return true
		}
	}
	return false
}

func latestVersion(slug lucytypes.PackageName) (v *datatypes.ModrinthVersion) {
	versions := listVersions(slug)
	for _, version := range versions {
		if version.VersionType == "release" &&
			(v == nil || version.DatePublished.After(v.DatePublished)) {
			v = version
		}
	}
	if v == nil {
		logger.Info("no release version found for " + slug.Title())
	} else {
		logger.Info("latest version of " + slug.String() + ": " + v.VersionNumber.String())
	}
	return v
}

func LatestCompatibleVersion(slug lucytypes.PackageName) (v *datatypes.ModrinthVersion) {
	versions := listVersions(slug)
	serverInfo := local.GetServerInfo()
	if serverInfo.Executable == local.UnknownExecutable {
		logger.Info("no executable found, unable to infer a compatible version. falling back to latest version")
		return latestVersion(slug)
	}
	for _, version := range versions {
		for _, gameVersion := range version.GameVersions {
			if gameVersion == serverInfo.Executable.GameVersion &&
				version.VersionType == "release" &&
				(v == nil || version.DatePublished.After(v.DatePublished)) {
				v = version
			}
		}
	}
	return v
}
